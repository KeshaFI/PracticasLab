A continuacion se mostraran primero los diagrmas UML, comenzando con el estatico.
\begin{figure}[h!]
    \centering
    \includegraphics[width=1\linewidth]{DiagramaEstatico.drawio.png}
    \caption{Diagrama estatico}
    \label{fig:placeholder}
\end{figure}

El diseño de clases propuesto implementa un sistema para gestionar servicios de vehículos de un taller mecánico, aplicando los pilares fundamentales de la Programación Orientada a Objetos (POO): Abstracción, Herencia, y Polimorfismo.


\subsection*{1. Interfaz (ServicioTaller) y Contrato}

El diseño se inicia con la Interfaz ServicioTaller, la cual define un contrato de funcionalidad que debe ser implementado obligatoriamente por cualquier clase que quiera ser gestionada como un "Servicio de Taller".

\begin{itemize}
    \item Métodos del Contrato:
    \begin{itemize}
        \item calcularServicio(): Obliga a calcular el costo del servicio.
        \item generarReporteServicio(): Obliga a generar un informe detallado del servicio.
    \end{itemize}
\end{itemize}

Esta interfaz garantiza la interoperabilidad: cualquier vehículo que cumpla con este contrato puede ser tratado de forma genérica como un objeto capaz de ser atendido en el taller.



\subsection*{2. Clase Base Abstracta (Vehiculo) y Abstracción}

La clase Vehiculo es una clase abstracta. Esto significa que no se pueden crear instancias directas de Vehiculo; solo se pueden instanciar sus subclases concretas.

\begin{itemize}
    \item Implementación de Interfaz: La clase Vehiculo es la que formalmente implementa la interfaz ServicioTaller. Esto asegura que todos los vehículos, independientemente de su tipo, cumplirán con el contrato de servicio.
    \item Abstracción de Atributos Comunes: Esta clase encapsula los atributos esenciales compartidos por todos los vehículos: \_marca, \_modelo, y \_anio. También proporciona métodos comunes, como descripcion(), que ofrece una representación básica del vehículo.
\end{itemize}


\subsection*{3. Clases Concretas y Herencia}

Las clases Auto, Moto, y Camion son las clases concretas.

\begin{itemize}
    \item Relación de Herencia (Extends): Cada una de estas clases hereda de la clase Vehiculo, adquiriendo automáticamente sus atributos y el compromiso de implementar los métodos del contrato de servicio.
    \item Atributos Específicos: Cada clase introduce atributos únicos relevantes para su tipo (\_tieneAireAcondicionado en Auto, \_cilindrada en Moto, \_capacidadToneladas en Camion).
\end{itemize}


\subsection*{4. Polimorfismo y Especialización}

El principio de Polimorfismo (múltiples formas) es fundamental en este diseño y se evidencia en la sobreescritura (@override) de los métodos heredados.

\begin{itemize}
    \item Sobreescritura de Métodos (@override): Aunque todos los vehículos deben calcularServicio() y generarReporteServicio() (por el contrato de la interfaz), la lógica de cómo se hace es específica para cada tipo de vehículo.
    \item Ejemplo: El método calcularServicio() en la clase Auto incluye un recargo por aire acondicionado, mientras que en la clase Camion incluye costos por revisión de frenos y suspensión, y un recargo por capacidad de carga.
\end{itemize}

Esta especialización a través del polimorfismo permite que el sistema trate a todos los objetos de manera uniforme (como un ServicioTaller), mientras ejecuta el comportamiento adecuado para su tipo específico.



Para el diagrama dinámico:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{uml_dinamico.png}
    \caption{Diagrama dinamico}
    \label{fig:placeholders}
\end{figure}

Para cumplir con el modelado del comportamiento, se representa el polimorfismo que ocurre cuando el usuario selecciona la opción "Ver reportes detallados". El diagrama muestra cómo la función \textbf{mostrarReportesDetallados} trata a todos los vehículos disponibles de la misma manera pero cada objeto responde de manera diferente.

\textbf{Polimorfismo}

La flotilla no necesita saber si se trata de un auto, motocicleta o camión, trata a todos sus elementos como un vehículo genérico. Envía el mismo mensaje -\textit{generarReporteServicio()}- y, gracias al enlace dinámico -\textit{dynamic binding}- de Dart, el sistema selecciona en tiempo de ejecución la versión correcta @override del método que debe ejecutarse.

Esta misma no sabe cómo auto calculó su servicio, simplemente confía en que el objeto sabe cómo hacerlo, esto se debe a la lógica interna llamada \textit{calcularServicio()}, que está oculta dentro del objeto, es decir, está encapsulado.

\textbf{Bucle y mensaje polimórfico}
La función que opera sobre el objeto flotilla inicia un bucle que itera sobre cada elemento "v" de su colección. Dentro del bucle, flotilla envía el mismo mensaje -\textit{v.generarReporteServicio()}- al primer objeto, que resulta ser un auto. Este mismo recibe el mensaje y completa el reporte haciendo una auto-llamada de \textit{calcularServicio()} para devolver el reporte formateado.

Para la siguiente iteración el bucle envía el mismo mensaje al siguiente objeto que es una moto, hace lo mismo que auto pero hace su propia versión de \textit{calcularServicio()} que en este caso utiliza la cilindrada para efectuar su cálculo. El bucle continuará de la misma manera para los demás vehículos, finalmente la función \textit{mostrarReportesDetallados} imprime los resultados en la consola.



