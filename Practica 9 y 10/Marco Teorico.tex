\subsection{Clases y objetos}
Dart es un lenguaje orientado a objetos con clases y herencia basada en mixins. Cada objeto es una instancia de una clase, y todas las clases, excepto Null, descienden de Object. La herencia basada en mixins significa que, aunque cada clase (excepto la clase superior, ¿Object?) tiene exactamente una superclase, el cuerpo de una clase se puede reutilizar en múltiples jerarquías de clases. Los métodos de extensión son una forma de añadir funcionalidad a una clase sin cambiarla ni crear una subclase. Los modificadores de clase permiten controlar cómo las bibliotecas pueden subtipificar una clase.\cite{dart_language}

En la programación orientada a objetos , un objeto es una unidad autocontenida de código y datos. Los objetos se crean a partir de plantillas llamadas clases. Un objeto se compone de propiedades (variables) y métodos (funciones). Un objeto es una instancia de una clase.\cite{dart_language}
\begin{itemize}
    \item Utilizando miembros de clase:
    
    Los objetos tienen miembros que consisten en funciones y datos ( métodos y variables de instancia , respectivamente). Al llamar a un método, se invoca sobre un objeto: el método tiene acceso a las funciones y datos de ese objeto.
    Utilice un punto (.) para referirse a una variable de instancia o método:

    
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
var p = Point(2, 2);

// Get the value of y.
assert(p.y == 2);

// Invoke distanceTo() on p.
double distance = p.distanceTo(Point(4, 4));
\end{lstlisting}
\end{center}
Utilice ?.en su lugar .para evitar una excepción cuando el operando más a la izquierda sea nulo:
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
// If p is non-null, set a variable equal to its y value.
var a = p?.y;
\end{lstlisting}
\end{center}
\item Utilizando constructores
Puedes crear un objeto usando un constructor . Los nombres de los constructores pueden ser `init` ClassNameo `init` . Por ejemplo, el siguiente código crea objetos usando los constructores `init` y `init`: ClassName.identifierPointPoint()Point.fromJson().\cite{dart_language}
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
var p1 = Point(2, 2);
var p2 = Point.fromJson({'x': 1, 'y': 2});
\end{lstlisting}
\end{center}
El siguiente código tiene el mismo efecto, pero utiliza la newpalabra clave opcional antes del nombre del constructor:
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
var p1 = new Point(2, 2);
var p2 = new Point.fromJson({'x': 1, 'y': 2});
\end{lstlisting}
\end{center}
\item Variables y métodos de clase

utilice la static palabra clave para implementar variables y métodos de toda la clase.
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Queue {
  static const initialCapacity = 16;
  // ···
}

void main() {
  assert(Queue.initialCapacity == 16);
}
\end{lstlisting}
\end{center}
\item métodos estáticos

Los métodos estáticos (métodos de clase) no operan sobre una instancia y, por lo tanto, no tienen acceso a ella this. Sin embargo, sí tienen acceso a las variables estáticas. Como muestra el siguiente ejemplo, los métodos estáticos se invocan directamente en una clase.\cite{dart_language}
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
import 'dart:math';

class Point {
  double x, y;
  Point(this.x, this.y);

  static double distanceBetween(Point a, Point b) {
    var dx = a.x - b.x;
    var dy = a.y - b.y;
    return sqrt(dx * dx + dy * dy);
  }
}

void main() {
  var a = Point(2, 2);
  var b = Point(4, 4);
  var distance = Point.distanceBetween(a, b);
  assert(2.8 < distance && distance < 2.9);
  print(distance);
}
\end{lstlisting}
\end{center}
\end{itemize}
\subsection{Constructores}
Los constructores son funciones especiales que crean instancias de clases.

Dart implementa muchos tipos de constructores. Excepto los constructores por defecto, estas funciones utilizan el mismo nombre que su clase.\cite{dart_language}
\medskip
\begin{enumerate}
    \item constructores generativos
Para instanciar una clase, utilice un constructor generativo.
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Point {
  // Instance variables to hold the coordinates of the point.
  double x;
  double y;

  // Generative constructor with initializing formal parameters:
  Point(this.x, this.y);
}
\end{lstlisting}
\end{center}
\item Constructores por defecto

Si no declaras un constructor, Dart utiliza el constructor predeterminado. El constructor predeterminado es un constructor generativo sin argumentos ni nombre.\cite{dart_language}
\item Constructores con nombre

Utilice un constructor con nombre para implementar múltiples constructores para una clase o para proporcionar mayor claridad:
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
vconst double xOrigin = 0;
const double yOrigin = 0;

class Point {
  final double x;
  final double y;

  // Sets the x and y instance variables
  // before the constructor body runs.
  Point(this.x, this.y);

  // Named constructor
  Point.origin() : x = xOrigin, y = yOrigin;
}
\end{lstlisting}
\end{center}
Una subclase no hereda el constructor con nombre de la superclase. Para crear una subclase con un constructor con nombre definido en la superclase, implemente dicho constructor en la subclase.
\item Constructores constantes

Si tu clase produce objetos que no cambian, haz que estos objetos sean constantes en tiempo de compilación. Para ello, define un constconstructor con todas las variables de instancia establecidas como final.\cite{dart_language}
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class ImmutablePoint {
  static const ImmutablePoint origin = ImmutablePoint(0, 0);

  final double x, y;

  const ImmutablePoint(this.x, this.y);
}
\end{lstlisting}
\end{center}
Los constructores constantes no siempre crean constantes. Pueden invocarse fuera de un constcontexto. Para obtener más información, consulte la sección sobre el uso de constructores .
\item Constructores de redireccionamiento

Un constructor puede redirigir a otro constructor de la misma clase. Un constructor que redirige tiene un cuerpo vacío. El constructor utiliza thisen lugar del nombre de la clase después de dos puntos ( :).
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Point {
  double x, y;

  // The main constructor for this class.
  Point(this.x, this.y);

  // Delegates to the main constructor.
  Point.alongXAxis(double x) : this(x, 0);
}
\end{lstlisting}
\end{center}
\end{enumerate}
\subsection{Encapsulacion, Getters y Setters}

En Dart, la encapsulación consiste en ocultar datos dentro de una biblioteca, protegiéndolos de factores externos. Esto ayuda a controlar el programa y evita que se vuelva demasiado complejo.\cite{dartTutorial_generics}

La encapsulación se puede lograr mediante:
\begin{itemize}
    \item Declarar las propiedades de la clase como privadas utilizando guion bajo () .
    \item Proporcionar métodos públicos getter y setter para acceder y actualizar el valor de la propiedad privada.
\end{itemize}
Nota:
Dart no admite palabras clave como `public` , `private` y `protected. Dart utiliza ```\textbf{\_}'' (guion bajo) para indicar que una propiedad o método es privado.
Los métodos getter y setter se utilizan para acceder y actualizar el valor de una propiedad privada. Los métodos getter se utilizan para acceder al valor de una propiedad privada. Los métodos setter se utilizan para actualizar el valor de una propiedad privada.\cite{dartTutorial_generics}

Ejemplo 1:
En este ejemplo, crearemos una clase llamada \texttt{Employee}. Esta clase tendrá dos propiedades privadas: $\mathbf{\_}$id y $\mathbf{\_}$name. También crearemos dos métodos públicos, \texttt{getId()} y \texttt{getName()}, para acceder a las propiedades privadas. Asimismo, crearemos dos métodos públicos, \texttt{setId()} y \texttt{setName()}, para actualizar las propiedades privadas.\cite{dartTutorial_generics}


\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Employee {
  // Private properties
  int? _id;
  String? _name;

// Getter method to access private property _id
  int getId() {
    return _id!;
  }
// Getter method to access private property _name
  String getName() {
    return _name!;
  }
// Setter method to update private property _id
  void setId(int id) {
    this._id = id;
  }
// Setter method to update private property _name
  void setName(String name) {
    this._name = name;
  }
  
}

void main() {
  // Create an object of Employee class
  Employee emp = new Employee();
  // setting values to the object using setter
  emp.setId(1);
  emp.setName("John");

  // Retrieve the values of the object using getter
  print("Id: ${emp.getId()}");
  print("Name: ${emp.getName()}");
}
\end{lstlisting}
\end{center}
En Dart, puedes controlar el acceso a las propiedades e implementar la encapsulación mediante el uso de propiedades de solo lectura. Para ello, añade la palabra clave ` final` antes de la declaración de la propiedad. De esta forma, solo podrás acceder a su valor, pero no modificarlo.\cite{dartTutorial_generics}
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Student {
  final _schoolname = "ABC School";

  String getSchoolName() {
    return _schoolname;
  }
}

void main() {
  var student = Student();
  print(student.getSchoolName());
  // This is not possible
  //student._schoolname = "XYZ School";
}
\end{lstlisting}
\end{center}

Puedes crear métodos getter y setter usando las palabras clave \texttt{get} y \texttt{set}. En el siguiente ejemplo, hemos creado una clase llamada \texttt{Vehicle}. Esta clase tiene dos propiedades privadas: $\mathbf{\_}$model y $\mathbf{\_}$year. También hemos creado dos métodos getter y setter para cada propiedad. Estos métodos se llaman \texttt{model} y \texttt{year}, y se utilizan para acceder y actualizar el valor de las propiedades privadas.\cite{dartTutorial_generics}
\medskip

\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Vehicle {
  String _model;
  int _year;

  // Getter method
  String get model => _model;

  // Setter method
  set model(String model) => _model = model;

  // Getter method
  int get year => _year;

  // Setter method
  set year(int year) => _year = year;
}

void main() {
  var vehicle = Vehicle();
  vehicle.model = "Toyota";
  vehicle.year = 2019;
  print(vehicle.model);
  print(vehicle.year);
}
\end{lstlisting}
\end{center}
¿Por qué es importante la encapsulación?
\begin{enumerate}
    \item Ocultación de datos : La encapsulación oculta los datos del exterior. Impide que el código fuera de la clase acceda a ellos. Esto se conoce como ocultación de datos.\cite{dartTutorial_generics}
    \item Facilidad de prueba : La encapsulación permite probar la clase de forma aislada. Esto permite probar la clase sin necesidad de probar el código fuera de ella.\cite{dartTutorial_generics}
    \item Flexibilidad : La encapsulación permite cambiar la implementación de la clase sin afectar al código que se encuentra fuera de la clase.\cite{dartTutorial_generics}
    \item Seguridad : La encapsulación permite restringir el acceso a los miembros de la clase. Esto permite limitar el acceso a los miembros de la clase desde el código externo a la biblioteca.\cite{dartTutorial_generics}


\end{enumerate}
\subsection{Herencia}
La herencia es la compartición de comportamiento entre dos clases. Permite definir una clase que extiende la funcionalidad de otra. La palabra clave `extend` se utiliza para heredar de la clase padre.\cite{dartTutorial_generics}

 Cuando se utiliza la herencia, siempre se crea una relación "es un/una" entre la clase padre y la clase hija, como por ejemplo: Estudiante es una Persona , Camión es un Vehículo , Vaca es un Animal , etc.

 Dart admite herencia simple, lo que significa que una clase solo puede heredar de una única clase. Dart no admite herencia múltiple, lo que significa que una clase no puede heredar de varias clases.\cite{dartTutorial_generics}
 \begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class ParentClass {
  // Parent class code
}

class ChildClass extends ParentClass {
  // Child class code
}
\end{lstlisting}
\end{center}
En esta sintaxis, ParentClass es la superclase y ChildClass es la subclase. ChildClass hereda las propiedades y métodos de ParentClass .

Términos:
\begin{itemize}
    \item Clase padre: La clase cuyas propiedades y métodos hereda otra clase se denomina clase padre. También se la conoce como clase base o superclase.\cite{dartTutorial_generics}
    \item Clase hija: La clase que hereda las propiedades y métodos de otra clase se denomina clase hija. También se la conoce como clase derivada o subclase.\cite{dartTutorial_generics}
\end{itemize}
Ejemplo 1:
En este ejemplo, crearemos una clase Persona y luego crearemos una clase Estudiante que hereda las propiedades y métodos de la clase Persona
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Person {
  // Properties
  String? name;
  int? age;

  // Method
  void display() {
    print("Name: $name");
    print("Age: $age");
  }
}
// Here In student class, we are extending the
// properties and methods of the Person class
class Student extends Person {
  // Fields
  String? schoolName;
  String? schoolAddress;

  // Method
  void displaySchoolInfo() {
    print("School Name: $schoolName");
    print("School Address: $schoolAddress");
  }
}

void main() {
  // Creating an object of the Student class
  var student = Student();
  student.name = "John";
  student.age = 20;
  student.schoolName = "ABC School";
  student.schoolAddress = "New York";
  student.display();
  student.displaySchoolInfo();
}
\end{lstlisting}
\end{center}

Ventajas de la herencia:
\begin{itemize}
    \item Promueve la reutilización del código y reduce el código redundante
    \item Ayuda a diseñar un programa de mejor manera.
    \item Simplifica y limpia el código, y ahorra tiempo y dinero en mantenimiento.
    \item Facilita la creación de bibliotecas de clases.
    \item Puede utilizarse para imponer una interfaz estándar a todas las clases hijas.
\end{itemize}
\subsection{Polimorfismo}
Poli significa muchos y morfo significa formas . El polimorfismo es la capacidad de un objeto para adoptar muchas formas. Como seres humanos, tenemos la capacidad de adoptar muchas formas. Podemos ser estudiantes, profesores, padres, amigos, etc. De manera similar, en la programación orientada a objetos, el polimorfismo es la capacidad de un objeto para adoptar muchas formas.\cite{dartTutorial_generics}

La sobreescritura de métodos es una técnica que permite crear un método en la clase hija con el mismo nombre que el método en la clase padre. El método en la clase hija sobreescribe el método en la clase padre.\cite{dartTutorial_generics}
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class ParentClass{
void functionName(){
  }
}
class ChildClass extends ParentClass{
@override 
void functionName(){
  }
}
\end{lstlisting}
\end{center}
Ejemplo 1:  Polimorfismo mediante la sobreescritura de métodos en Dart

En el siguiente ejemplo, existe una clase llamada Animal con un método llamado eat() . El método eat() se redefine en la clase hija llamada Dog .

\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
class Animal {
  void eat() {
    print("Animal is eating");
  }
}

class Dog extends Animal {
  @override
  void eat() {
    print("Dog is eating");
  }
}

void main() {
  Animal animal = Animal();
  animal.eat();

  Dog dog = Dog();
  dog.eat();
}
\end{lstlisting}
\end{center}

Ventaja de usar polimorfismo:

\begin{enumerate}
    \item Las subclases pueden anular el comportamiento de la clase padre.
    \item Nos permite escribir código más flexible y reutilizable.
    
\end{enumerate}
\subsection{Clase abstracta}
Las clases abstractas son clases que no se pueden inicializar. Se utilizan para definir el comportamiento de una clase que puede ser heredado por otras clases. Una clase abstracta se declara utilizando la palabra clave abstract.\cite{dartTutorial_generics}
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
abstract class ClassName {
  //Body of abstract class

  method1();
  method2();
}
\end{lstlisting}
\end{center}
Un método abstracto es un método que se declara sin implementación. Se declara con un punto y coma (;) en lugar del cuerpo del método.\cite{dartTutorial_generics}
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
abstract class ClassName {
  //Body of abstract class
  method1();
  method2();
}
\end{lstlisting}
\end{center}
Las subclases de una clase abstracta deben implementar todos los métodos abstractos de la clase abstracta. Se utiliza para lograr la abstracción en el lenguaje de programación Dart.\cite{dartTutorial_generics}

Ejemplo 1:
\medskip
  En el siguiente ejemplo, hay una clase abstracta Vehículo con dos métodos abstractos start() y stop(). Las subclases Auto y Bicicleta implementan los métodos abstractos y los sobrescriben para imprimir el mensaje..\cite{dartTutorial_generics}
 \medskip
 \begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
abstract class Vehicle {
  // Abstract method
  void start();
  // Abstract method
  void stop();
}

class Car extends Vehicle {
  // Implementation of start()
  @override
  void start() {
    print('Car started');
  }

  // Implementation of stop()
  @override
  void stop() {
    print('Car stopped');
  }
}

class Bike extends Vehicle {
  // Implementation of start()
  @override
  void start() {
    print('Bike started');
  }

  // Implementation of stop()
  @override
  void stop() {
    print('Bike stopped');
  }
}

void main() {
  Car car = Car();
  car.start();
  car.stop();

  Bike bike = Bike();
  bike.start();
  bike.stop();
}
\end{lstlisting}
\end{center}
\medskip
Nota: La clase abstracta se utiliza para definir el comportamiento de una clase que puede ser heredada por otras clases. Se puede definir un método abstracto dentro de una clase abstracta.\cite{dartTutorial_generics}

No se puede crear un objeto de una clase abstracta. Sin embargo, se puede definir un constructor en una clase abstracta. El constructor de una clase abstracta se invoca cuando se crea un objeto de una subclase.\cite{dartTutorial_generics}

Ejemplo 2:
En el siguiente ejemplo, hay una clase abstracta Bank con un constructor que toma dos parámetros: nombre y tasa. Hay un método abstracto interest(). Las subclases SBI e ICICI implementan el método abstracto y lo sobrescriben para imprimir la tasa de interés.
\medskip
\begin{center}
\begin{lstlisting}[
    % Opciones para la apariencia:
    frame=single,    % Dibuja el recuadro (el marco)
    numbers=left     % Muestra la numeración a la izquierda
    % Puedes añadir las opciones de centrado si es necesario:
    % xleftmargin=0.1\textwidth,
    % xrightmargin=0.1\textwidth
]
abstract class Bank {
  String name;
  double rate;

  // Constructor
  Bank(this.name, this.rate);

  // Abstract method
  void interest();

  //Non-Abstract method: It have an implementation
  void display() {
    print('Bank Name: $name');
  }
}

class SBI extends Bank {
  // Constructor
  SBI(String name, double rate) : super(name, rate);

  // Implementation of interest()
  @override
  void interest() {
    print('The rate of interest of SBI is $rate');
  }
}

class ICICI extends Bank {
  // Constructor
  ICICI(String name, double rate) : super(name, rate);

  // Implementation of interest()
  @override
  void interest() {
    print('The rate of interest of ICICI is $rate');
  }
}

void main() {
  SBI sbi = SBI('SBI', 8.4);
  ICICI icici = ICICI('ICICI', 7.3);

  sbi.interest();
  icici.interest();
  icici.display();
}
\end{lstlisting}
\end{center}
